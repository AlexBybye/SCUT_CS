### 一、常见的小型嵌入式操作系统
#### 1. 系统列举
RT - Thread、Amazon FreeRTOS、μC/OS、华为LiteOS、AliOSThings、ARM mbed、Tencent OStiny。

#### 2. 特点
- **内核精简**：主要由任务管理、时间管理、互斥量、信号量、内存管理等基础元素构成。
- **轻量高效**：程序体积通常小于4KB，可直接部署在微控制器的静态存储器上，通过地址总线访问即可运行。
- **实时性强**：适合对实时性要求较高的嵌入式场景，如工业控制、物联网设备等。

#### 3. 功能
- **任务管理**：支持多任务调度，可管理数十个任务，如μC/OS - II最多可管理64个任务（其中8个系统保留）。
- **实时调度**：采用基于优先级的抢占式调度算法，确保高优先级任务优先执行。
- **通信机制**：提供信号量、互斥信号量（MUTEX）、消息邮箱、消息队列、事件标志组等通信方式，实现任务间的同步与数据交互。
- **内存管理**：支持静态内存分配和动态内存管理（如μC/OS - II的内存分区管理），避免内存碎片问题。
- **中断处理**：支持中断嵌套（μC/OS - II嵌套层数可达255层），中断响应迅速。


### 二、小型嵌入式系统开发过程（以μC/OS - II为例）
#### 1. 实验准备
- **硬件选型**：选择合适的微控制器，如STM32系列，确保其满足操作系统移植要求（如支持中断、硬件堆栈等）。
- **开发工具**：安装集成开发环境（如Keil MDK）、仿真工具（如Proteus），并配置相关驱动和库文件。

#### 2. 开发步骤
- **硬件初始化**：编写代码初始化微控制器的外设，如GPIO、串口、定时器等，为操作系统运行提供基础硬件环境。
- **操作系统初始化**：调用`OSInit()`函数初始化μC/OS - II内核，创建系统所需的内部数据结构（如任务控制块TCB、事件控制块ECB等）。
- **任务创建**：使用`OSTaskCreate()`或`OSTaskCreateExt()`函数创建应用任务，指定任务函数、参数、堆栈和优先级。例如，创建一个LED控制任务：
    ```c
    OS_STK LEDStk[TASK_STK_SIZE];  // 定义任务堆栈
    OSTaskCreate(LEDTask, (void *)0, &LEDStk[TASK_STK_SIZE - 1], 0);  // 创建任务
    ```
- **启动任务调度**：调用`OSStart()`函数启动多任务调度，操作系统开始管理任务的执行。
- **调试与仿真**：通过Proteus仿真工具或硬件调试器（如ST - Link）对系统进行调试，观察任务执行、中断响应、数据通信等是否正常。


### 三、移植嵌入式操作系统的思路（以μC/OS - II为例）
#### 1. 处理器要求
- 处理器的C编译器能产生可重入代码。
- 能用C语言打开和关闭中断。
- 支持中断，且能产生定时中断（频率通常在10 - 100Hz之间）。
- 支持足够容量的硬件堆栈（可能为几KB）。
- 具备将堆栈指针和其他CPU寄存器读出、存储到堆栈或内存中的指令。

#### 2. 移植步骤
- **修改头文件（OS_CPU.H）**
    - **定义数据类型**：使用与处理器无关的整数类型（如`OS_STK`、`INT8U`等），避免依赖C语言的默认数据类型。
    - **设置堆栈生长方向**：ARM处理器通常使用满递减堆栈，设置`OS_STK_GROWTH = 1`。
    - **定义中断开关宏**：通过汇编或C语言实现`OS_ENTER_CRITICAL()`（关中断）和`OS_EXIT_CRITICAL()`（开中断）宏，例如：
    ```c
    #define OS_CRITICAL_METHOD 3
    #define OS_ENTER_CRITICAL() (cpu_sr = OSCPUSaveSR())  // 关中断
    #define OS_EXIT_CRITICAL() (OSCPURestoreSR(cpu_sr))    // 开中断
    ```
- **编写C语言接口（OS_CPU_C.C）**
    - **任务堆栈初始化函数（`OSTaskStkInit()`）**：根据处理器的寄存器结构，初始化任务堆栈，模拟任务被中断时的寄存器压栈状态。
    - **Hook函数**：实现用户自定义的Hook函数（如任务创建、删除Hook），可为空函数，供用户扩展。
- **编写汇编语言代码（OS_CPU_A.ASM）**
    - **任务切换函数（`OSCtxSw()`）**：实现任务级上下文切换，保存当前任务的寄存器到堆栈，恢复下一个任务的寄存器从堆栈。
    - **中断级切换函数（`OSIntCtxSw()`）**：在中断服务程序中实现任务切换，利用中断机制自动保存/恢复部分寄存器。
    - **启动最高优先级任务函数（`OSStartHighRdy()`）**：在系统启动时，从任务控制块中获取最高优先级任务的堆栈指针，恢复其上下文并启动执行。


### 四、μC/OS - II的特点及开发过程
#### 1. 特点
- **公开开源**：内核代码完全公开，便于学习和定制，但商用需注意版权许可。
- **可移植性强**：大部分代码用ANSI C编写，与处理器相关部分用汇编编写，易于移植到8位、16位、32位处理器。
- **可裁剪**：通过条件编译（`OS_CFG.H`）可选择性编译所需功能，减少代码体积。
- **实时性高**：完全抢占式内核，任务切换和中断响应时间可确定，适合硬实时系统。
- **功能丰富**：提供信号量、互斥量、邮箱、消息队列、事件标志组、动态内存管理等多种系统服务。

#### 2. 开发过程
- **系统设计**：根据需求规划任务数量、优先级、通信方式和资源分配。
- **代码编写**
    - 编写硬件驱动代码（如GPIO、串口、定时器驱动）。
    - 编写应用任务代码，调用操作系统API实现任务逻辑（如延时`OSTimeDly()`、发送信号量`OSSemPost()`等）。
    - 配置`OS_CFG.H`，启用或禁用系统功能（如是否启用消息队列、互斥量等）。
- **调试与优化**：通过调试工具排查任务调度、资源竞争等问题，优化任务堆栈大小、中断处理时间等性能指标。


### 五、OpenHarmony嵌入式操作系统（补充知识，PPT未详细提及）
#### 1. 特点
- **分布式架构**：支持多设备协同，实现“一次开发，多端部署”，适合物联网场景。
- **低功耗**：针对嵌入式设备优化电源管理，延长电池续航。
- **模块化设计**：采用组件化架构，可按需裁剪系统功能，适应不同硬件配置。
- **安全可靠**：内置安全子系统，支持设备身份认证、数据加密等安全机制。

#### 2. 开发过程
- **环境搭建**：安装DevEco Studio开发工具，配置OpenHarmony编译环境（如Python、Node.js、hb工具等）。
- **应用开发**
    - 使用JS/Java/C++等语言开发应用逻辑，调用OpenHarmony提供的API（如分布式任务调度、设备管理等）。
    - 设计UI界面，支持自适应不同屏幕尺寸和分辨率。
- **设备适配**：针对不同硬件平台（如STM32、RK系列芯片），移植OpenHarmony内核和驱动，实现硬件抽象层（HAL）和板级支持包（BSP）。
- **调试与部署**：通过HiLens等工具进行应用调试，使用烧录工具将系统镜像部署到硬件设备。


### 总结
小型嵌入式操作系统以轻量、实时、可裁剪为核心特点，开发过程需结合硬件初始化与操作系统任务管理。移植操作系统需深入理解处理器架构与内核原理，而μC/OS - II和OpenHarmony分别代表了传统实时系统与新兴分布式系统的典型开发模式。实际开发中需根据项目需求（如实时性、设备互联）选择合适的操作系统，并灵活运用其提供的功能组件。