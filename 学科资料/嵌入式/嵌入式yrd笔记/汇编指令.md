寄存器既可以存储数值（如整数、浮点数），也可以存储地址（内存指针）

### **一、数据传送指令**
#### **1. MOV（Move）**
- **功能**：将立即数或寄存器值传送到目标寄存器，可带移位操作。  
- **格式**：  
  ```assembly
  MOV{cond}{S} Rd, operand2  ; operand2可为寄存器或立即数
  ```  
- **特点**：  
  - 不访问内存，仅操作寄存器或立即数。  
  - 支持寄存器移位寻址（如 `MOV R0, R2, LSL #3`）。  
  - 立即数需为**8位位图常数**（如 `#0xFF`、`#0xC000`）。  
- **示例**：  
  ```assembly
  MOV R0, #0        ; 寄存器R0清零（立即寻址）
  MOV R1, R2        ; 将R2的值复制到R1（寄存器寻址）
  MOV R3, R1, LSR #2 ; R1右移2位后存入R3（寄存器移位寻址）
  ```

#### **2. LDR/STR（Load/Store）**
- **功能**：  
  - **LDR**：从内存读取数据到寄存器（字/字节操作）。  
  - **STR**：将寄存器数据写入内存（字/字节操作）。  
- **格式**：  
  ```assembly
  LDR{cond}{B} Rd, [Rn, #offset]  ; 加载字（默认）或字节（B后缀）
  STR{cond}{B} Rd, [Rn, #offset]  ; 存储字（默认）或字节（B后缀）
  ```  
- **特点**：  
  - **字操作**：访问4字节内存，地址需字对齐（默认，如 `LDR R1, [R2]`）。  
  - **字节操作**：访问1字节内存，用 `B` 后缀（如 `LDRB R1, [R2]`、`STRB R1, [R2]`）。  
  - 支持基址寻址（如 `[Rn, #offset]`），`offset` 可为立即数或寄存器。  
- **示例**：  
  ```assembly
  LDR R1, [R0]     ; 读取R0指向的内存单元（字数据）→ R1（寄存器间接寻址）
  STR R1, [R0, #4] ; 将R1写入R0+4地址（基址寻址，不更新R0）
  LDRB R2, [R3, #-1]! ; 读取R3-1地址的字节数据→ R2，并更新R3=R3-1（带!更新基址）
  ```
### MOV R1, R0 与 LDR R1, [R0] 的区别
这两条指令虽然看起来相似，但执行的操作完全不同。我用一个具体例子来说明它们的区别：
### 假设初始状态
- R0 = 0x1000 (R0 存储了一个内存地址)
- 内存地址 0x1000 处的值为 0xAAAA (内存中存储的数据)
- R1 = 0x0000 (初始值为 0)
### MOV R1, R0 指令
```assembly
MOV R1, R0  ; 将 R0 的值复制到 R1
```

**执行结果**：
- R0 = 0x1000 (保持不变)
- R1 = 0x1000 (R1 现在保存了与 R0 相同的值，即地址 0x1000)
- 内存内容不变

**总结**：MOV 指令直接复制寄存器的值，不涉及内存访问。
### LDR R1, [R0] 指令
```assembly
LDR R1, [R0]  ; 从 R0 指向的内存地址读取数据到 R1
```

**执行步骤**：
1. 读取 R0 的值：0x1000
2. 访问内存地址 0x1000
3. 从该地址读取数据：0xAAAA
4. 将读取的数据存入 R1

**执行结果**：
- R0 = 0x1000 (保持不变)
- R1 = 0xAAAA (R1 现在保存了内存地址 0x1000 处存储的数据)
- 内存内容不变


### **二、算术运算指令**
#### **3. ADD（Add）**
- **功能**：寄存器与寄存器/立即数相加，结果存入目标寄存器。  
- **格式**：  
  ```assembly
  ADD{cond}{S} Rd, Rn, operand2  ; operand2可为寄存器或立即数
  ```  
- **特点**：  
  - 支持条件执行（如 `ADDEQ`）和影响标志位（带 `S` 后缀）。  
  - 立即数需符合8位位图规则。  
- **示例**：  
  ```assembly
  ADD R0, R1, #1    ; R1+1→ R0（立即寻址，无标志位更新）
  ADDS R2, R3, R4   ; R3+R4→ R2，并更新N/Z/C/V标志（带S后缀）
  ```

#### **4. SUB（Subtract）**
- **功能**：寄存器与寄存器/立即数相减，结果存入目标寄存器。  
- **格式**：  
  ```assembly
  SUB{cond}{S} Rd, Rn, operand2  ; operand2可为寄存器或立即数
  ```  
- **特点**：与ADD类似，支持条件执行和标志位更新。  
- **示例**：  
  ```assembly
  SUB R0, R0, #1    ; R0-1→ R0（常用于循环计数）
  SUBS R1, R2, R3   ; R2-R3→ R1，并更新标志位
  ```


### **三、逻辑运算指令**
#### **5. AND（Logical AND）**
- **功能**：对两个操作数执行按位与运算，结果存入目标寄存器。  
- **格式**：  
  ```assembly
  AND{cond}{S} Rd, Rn, operand2  ; 保留共同为1的位
  ```  
- **特点**：常用于**位掩码**（屏蔽不需要的位）。  
- **示例**：  
  ```assembly
  AND R1, R1, #0xFF  ; 保留R1的最低8位，其余位清零（字节提取）
  ANDS R2, R3, R4    ; R3 & R4→ R2，并更新标志位
  ```

#### **6. ORR（Logical OR）**
- **功能**：对两个操作数执行按位或运算，结果存入目标寄存器。  
- **格式**：  
  ```assembly
  ORR{cond}{S} Rd, Rn, operand2  ; 只要有1位为1，结果位为1
  ```  
- **特点**：常用于**位置1**（设置特定标志位）。  
- **示例**：  
  ```assembly
  ORR R0, R0, #0x01  ; 将R0的第0位置1，其余位不变
  ORR R5, R5, R6     ; R5 | R6→ R5（合并两个寄存器的位）
  ```


### **四、关键区别与注意事项**
1. **字操作 vs 字节操作**：  
   - `LDR/STR`：默认字操作（4字节），需地址对齐（如 `0x40000000`）。  
   - `LDRB/STRB`：显式字节操作（1字节），地址无需对齐（如 `0x40000001`）。  
   ```assembly
   LDR R1, [R0]   ; 读取字数据（假设R0=0x40000000，数据0x12345678）
   LDRB R1, [R0]  ; 读取字节数据（R1=0x78，低地址字节）
   ```
### 内存布局示例（小端序）
```
地址      内容(十六进制)
0x40000000  78  (低字节)
0x40000001  56
0x40000002  34
0x40000003  12  (高字节)
```

- LDR 读取完整的32位：0x12345678
- LDRB 只读取最低地址的字节：0x78


1. **标志位影响**：  
   - 带 `S` 后缀的指令（如 `ADDS`、`SUBS`、`ANDS`）会更新 **N（符号位）、Z（零标志）、C（进位）、V（溢出）**。  
   - 无 `S` 后缀则不影响标志位，适用于纯数据运算。  

3. **立即数限制**：  
   - 立即数需为**8位位图常数**，即通过8位值循环右移偶数位得到（如 `#0xFF`、`#0x300`）。  
   - 非法立即数（如 `#0x1234`）需用 `LDR` 从内存加载。  


### **五、典型应用场景**
- **初始化与数据处理**：  
  ```assembly
  MOV R0, #0       ; 初始化寄存器为0
  LDR R1, [R2]     ; 从外设寄存器读取数据（如ADC结果）
  STR R3, [R4]     ; 将计算结果写入内存缓冲区
  ```

- **算术逻辑操作**：  
  ```assembly
  ADD R5, R5, #1   ; 计数器自增
  SUB R6, R6, R7   ; 差值计算
  AND R8, R9, #0x0F ; 提取低4位（如BCD码处理）
  ORR R10, R10, #0x80 ; 设置最高位为1（标志位设置）
  ```

- **字节操作场景**：  
  ```assembly
  LDRB R1, [R0]    ; 读取传感器的8位数据
  STRB R1, [R0]    ; 向LED控制寄存器写入8位模式
  ```


### **总结：快速记忆表**
| **指令** | **功能**               | **关键后缀/格式**       | **典型用法**                     |
|----------|------------------------|------------------------|----------------------------------|
| MOV      | 寄存器/立即数传送      | `MOV Rd, #imm`         | 初始化寄存器、移位运算           |
| LDR/STR  | 内存字数据读写         | `LDR Rd, [Rn, #offset]`| 外设数据交互、缓冲区操作         |
| LDRB/STRB| 内存字节数据读写       | `LDRB Rd, [Rn]`        | 8位设备（如I2C传感器）数据处理   |
| ADD/SUB  | 算术加减               | `ADDS Rd, Rn, #imm`    | 计数器、差值计算、条件判断       |
| AND/ORR  | 按位与/或              | `AND Rd, Rn, #mask`    | 位掩码（提取/设置）、标志位操作   |

通过以上讲解，可快速识别指令类型并应用于习题中，重点注意**寻址方式**（寄存器/立即数/内存）和**操作粒度**（字/字节）的区分。