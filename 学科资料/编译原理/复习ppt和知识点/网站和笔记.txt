1. 怎么求由正规式转化为NFA、DFA和最小化DFA
https://zhuanlan.zhihu.com/p/37900383
2. 怎么求FIRST集合FOLLOW集
https://blog.csdn.net/qq_45913371/article/details/124968261?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167737891516800225538672%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167737891516800225538672&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124968261-null-null.142^v73^wechat,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=FOLLOW%E9%9B%86&spm=1018.2226.3001.4187
3. 同一个终结符的不同产生式的SELECT集的交集为空集，这样的文法才是LL(1)文法
4. 求符号串的FIRST集，应该先观察第一个符号，如果第一个符号不能推导出空集，那么就直接用
FIRST(第一个符号)，否则从左往右继续观察，直到某个符号不能推导出空集，这时就将包括这个符号在内
的前面所有符号的FIRST集并上并减去ε(lower-case epsilon)。如果所有符号都能推出空集，那么再把
ε加进去
5. 需要满足LL(1)文法的语法分析方法包括 递归下降子程序法和预测分析法
6. LR(k)分析通过活前缀来帮助确定句柄，这一部分内容包括活前缀和可归约前缀的识别，使用DFA
7. 只要分析过程中符号栈里的符号串是个活前缀，就说明已经被分析的部分是正确的。
8. 拓广文法就是增加一个对开始符号S的推导：S'->S，剩下的不变
9. 构造好基于项目集规范族的DFA，推出ACTION和GOTO表就很容易了
10. 当一个文法的LR(0)项目集规范族中的项目集不存在移进-归约冲突和归约-归约冲突时这个文法就是LR(0)
文法。
11. SLR(1)的改进版在于归约的时候还需要观察推导式左边的FOLLOW集是否包含
比如A->r·，要看输入符号a是否在FOLLOW(A)中才决定是否归约，否则考虑同项目集中的移进
12. SLR(1)不满足的情况之一：归约-归约冲突时∩FOLLOW != ∅，即不能找出要归约谁。
13. 语法分析方法的比较主要针对LL(1)和LALR(1)两大主流：
① 简单性：LL(1)更简单
② 一般性：LALR(1)更一般，可以处理左递归
③ 语义动作的插入：LL(1)更灵活，允许其出现在产生式右部任何地方
④ 错误校正：LL(1)更好，因为LL(1)分析栈保存的是待匹配的语法符号，LALR(1)保存的是已经
匹配过的
⑤ 分析表大小：LL(1)更有优势
综上：LL(1)一般情况都好。
14. 错误分析和恢复分为3类：递归下降分析、LL分析、LR分析
15. 词法分析的描述工具包括正规文法和正则表达式；语法分析的描述工具包括上下文无关文法
16. 属性文法A = (G,V,F): G是一个上下文无关文法，V是属性的有穷集，F是关于属性的断言的有穷集
17. 属性包括综合属性和继承属性：
综合属性是内在属性，该属性值由子节点的属性值计算而来，用于自下而上传递信息
继承属性自上而下，属性值由父节点或兄弟节点计算而来。
词法分析器提供综合属性给终结符，终结符没有继承属性
文法开始符也没有继承属性，其他的普通非终结符可以涵盖两种属性
18. 中间代码有4种形式：逆波兰记号、三元式、四元式、树形表示
逆波兰也叫后缀式，运算符写后面，对象写前面，简单地说就是把AST进行后序遍历得到的结果，
	易于计算机栈处理
三元式：(op,arg1,arg2):运算符、对象1、对象2
四元式：(op,arg1,arg2,result):result表示运算结果存储在哪个变量
以上的参数列表都可以选择性空着，比如(=,t3,-,a)表示a=t3,第三个参数arg2不需要
19. 自下而上语法制导翻译的考试（可能）主要内容包括简单赋值语句、布尔表达式、
控制语句、简单说明语句
20. 拉链和回填：布尔表达式有true和false的出口，一开始不能确定，要待后续翻译做完才可以确定（回填）
21. 简单说明语句不产生中间代码，会有一个符号表（symbol table）来默默记录变量和属性
事实上符号表会在词法和语法分析过程中不断填入，用于予以检查和产生中间代码、生成
目标代码等不同的阶段。
说明语句：变量、函数声明语句等
22. 自上而下的语法制导翻译可以对应递归下降法和LL分析法两种方式
23. 递归下降法很简单，我实验做过，就是在子程序里插入一段代码，来实现赋值、类型检查等语义动作
24. LL(1)分析法是让产生式右部逐个文法符号与输入串匹配，每获得一个匹配就可以执行相应的语义动作
衍生出一个概念：动作文法（Action Grammar）
25. S-属性文法：所有属性都是综合属性，是L-属性文法的特例
L-属性文法：对于每个产生式X_0->X_1X_2......X_n的每个语义规则中，每个属性要不是综合属性，要不
对于X_i的属性a_j满足：
X_i.a_j = f_{ij} (X_0.a1~ak,X_1.a1~ak,......,X_{i-1}.a1~ak)
个人理解：Xi的某个叫aj的属性由表达式中他左边和父亲的每个X的各个属性确定（兄弟+父亲节点？）
26. 目标程序运行的存储组织要解决的问题在于：把静态的程序和程序运行时的动态活动联系起来
即运行中的程序信息如何进行存储和访问，其中存储组织表示编译阶段定义的各种量要在运行时分配
存储空间。
27. 存储空间结构在文件夹里有图，空间分配的话要考虑静态存储分配、
栈式动态存储分配和堆式动态存储分配。这是一个可能的考点
· 静态存储分配：FORTRAN语言，编译的时候就分配好了，适用于不允许递归过程或递归调用和可变体积的数据结构
· 栈式动态分配：C、PASCAL，开辟栈区，调用一个过程的时候就分配数据空间在栈顶，工作结束时释放（先借后还）
· 堆式动态分配：C++，需要的时候就开辟一片存储区借用一块，不用的时候再退还，可以自由申请，但容易
出现碎片，不好充分利用空间。
28. 参数：传值、传地址、传名
29. 编译阶段的代码优化：中间代码优化（不依赖具体计算机）、目标代码优化（依赖具体计算机）
优化本身又分为：局部优化、循环优化、全局优化等
30.  中间代码优化可以分为：①删除多余运算（删除公共子表达式）：比如前面有x=4*p，后面有
y=4*p，中间p也没改变，则后面的优化成y=x
②合并已知量和复写传播：x=4*p，p如果已知，比如=1，那么直接优化成x=4，后面如果不变，然后
有语句y=4*p，那么一样直接令y=x=4。复写传播就是如果后面再有z=y，中间x、y不变，那就直接把
x的值传递给z
③删除无用赋值：有些变量的赋值从未被引用。。。
31. 基本块概念，以及如何把一段程序分成若干基本块。。。基本块的DAG的构建算法：可能重点
32. DAG的应用：前面3种都包括。
33. 循环优化：流图。。。
优化的内容：
①代码外提：把循环不变运算提到循环前面，主要指那些循环时值不变的、循环外定值或者为常量的。。。
②强度削弱：比如乘法换成加法。。。
34. 代码生成的共同问题：寄存器分配算法和基本块的代码生成算法
代码生成器：基于基本块，输入四元式，输出M机器的汇编
在进入基本块的时候所有寄存器都是空闲的，离开出口时释放寄存器，有用的值存回内存，变量中间值尽量
存在寄存器里。
35. 待用信息链表法：待用信息：下次引用信息；定值、引用、活跃的概念
36. 寄存器描述数组RVALUE、变量地址描述数组AVALUE、寄存器分配函数GETREG（返回一个寄存器）
※其他有的没的
26. 正则表达式转换为DFA还有分割法哦

① 语法分析的五/六个阶段
https://developer.aliyun.com/article/613610
② 句型、短语、直接短语、句柄是怎么来的
https://blog.csdn.net/IT_DREAM_ER/article/details/53612006
③ 正规式、正规集和正则定义
https://blog.csdn.net/starter_____/article/details/86659588
④ 基本块的DAG化
https://zhuanlan.zhihu.com/p/331795662
https://www.cnblogs.com/xpwi/p/11073220.html
